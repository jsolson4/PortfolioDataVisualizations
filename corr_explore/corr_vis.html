
<meta charset="utf-8">

<!-- Class style sheet in linked in .css -->
<link rel="stylesheet" href = "ticker_styles.css" type="text/css"/>

<script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
<script src="user_interactions.js"></script>
<!-- // Tutorial Link: https://www.youtube.com/watch?v=y2-sgZh49dQ -->

<!-- Set title (correct placement?)-->
<title>Corr Explore</title>

<!-- Create left hand column-->
<!-- Left Quarter Column -->
<div class="left-column">
    <div class="left-column-content">
        <!-- Content for the left column goes here -->
        <h2>Corr Explore</h2>
        <p><i>This is an exciting new way to visualize portfolio correlation.</i></p>
    </div>

    <div class="slidecontainer">
        <input type="range" min="0" max="1" value="0.0" 
            step = "0.01" class="slider" id="corrRange">
            
<!-- Display the selected value -->
<p>Min. Correlation: <span id="corrMinValue">0.0</span></p>

<script>

    
//   // Add an event listener to the range slider
//   const rangeSlider = document.getElementById("corrRange");
//   const corrMinimumDisplay = document.getElementById("corrMinValue");

//     // Function to update node visibility based on the slider value
//     function updateNodeVisibility(corrMinvalue) {
//     graphData.nodes.attr("display", d => (d.Correlation >= corrMinvalue) ? "block" : "none");
//   }

//   rangeSlider.addEventListener("input", function() {
//     const corrMinValue = +this.value; // Convert the value to a number
//     corrMinimumDisplay.textContent = corrMinValue;
//     updateNodeVisibility(corrMinValue);
//   }
// );

</script>

<script>var slider = document.getElementById("corrRange")
;</script>
      </div>
</div>

<!-- Create a div where the graph will take place -->
<div class="right-column">




<svg id = "graph-container" width="800" height = "800"></svg>

<script>

// select the svg container
var svg = d3.select("#graph-container"); //ensure this works

var margin = {top: 20, right: 20, bottom: 30, left: 50}
var width = +svg.attr("width") - margin.left - margin.right;
var height = +svg.attr("height") - margin.top - margin.bottom;

console.log(margin, width, height)


d3.dsv(',', 'data/ticker_corr2.csv', function(d) {
    //if (d.Correlation >= corr_filter_min) {
    console.log(d.source, d.target, d.Correlation, d.norm_corr)
      return {
          source: d.source,
          target: d.target,
          correlation: +d.Correlation,
          value: isNaN(d.norm_corr) ? 0 : +d.norm_corr,
        }     
    //}
}).then(function(data) {

var links = data;
console.log("links:", links)
var nodes = [
              { name: 'GBDC', group:'Credit', Correlation: 0.393 }, 
              { name: 'POLY.L', group :'Mining', Correlation: 0.721 }, 
              { name: 'PSDN', group:'Cannabis', Correlation:0.854 }, 
              { name: 'SKF.AX', group:'Technology', Correlation:0.597 }, 
              { name: 'SSSS', group:'Technology', Correlation:0.695 }, 
              { name: 'TEK.AX', group:'Technology', Correlation: 0.784 },
              { name: 'VRNOF', group:'Cannabis', Correlation: 0.712 }];

var graphData = {nodes:nodes, links:links};

// Notes
// fix drag functionality
// add/test charge strength where nodes are specifically attracted to one another... may have to be invisible links?
console.log("width:", width/2, "height:", height/2)
// render issue was due to setting strength on forceCenter too high
var simulation = d3
        .forceSimulation(graphData.nodes)
        .force("charge", d3.forceManyBody().strength(4))//5
        .force("center", d3.forceCenter(width/2, height/2).strength(1))//1 
        .force("collide", 
            d3.forceCollide(function(d){
                return d.Correlation * 100 
            })
            .strength(0.8))//0.7
        .on("tick", ticked);

var drag = d3
    .drag()
    .on("start", dragStart)
    .on("drag", dragged)
    .on("end", dragEnded);

  // Add an event listener to the range slider
  const rangeSlider = document.getElementById("corrRange");
  const corrMinimumDisplay = document.getElementById("corrMinValue");

//     // Function to update node visibility based on the slider value
//     function updateNodeVisibility(corrMinvalue) {
//     graphData.nodes.attr("display", d => (d.Correlation >= corrMinvalue) ? "block" : "none");
//   }

  rangeSlider.addEventListener("input", function() {
    const corrMinValue = +this.value; // Convert the value to a number
    corrMinimumDisplay.textContent = corrMinValue;
    //updateNodeVisibility(corrMinValue);
  }
);

var textsAndNodes = svg
    .append("g")
    .selectAll("g")
    .data(graphData.nodes)
    .enter()
    .append("g")
    // .filter(function(d){ 
    //     console.log(d, d.Correlation, corrMinimumDisplay)
    //     return d.Correlation >= +corrMinimumDisplay.textContent })
    .call(drag)
    .on("click", clicked);


//textsAndNodes = textsAndNodes.filter(function(d){ return d.Correlation >= corrMinValue })

var circles = textsAndNodes
    .append("circle")
    .attr("class", "node")
    .attr("r", function(d){
        return d.Correlation * 100;
    })
    .attr("fill", "steelblue")
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    ;

var texts = textsAndNodes.append("text")
                         .attr("class", "text")
                         .text(function(d){return d.name;})

function ticked() {
    //translate(x,y)
    textsAndNodes.attr("transform", function(d){
        return "translate(" + d.x + ", " + d.y + ")";
    });



    


    // links
    // .attr("x1", function(d){
    //     return d.source.x;
    // })
    // .attr("y1", function(d){
    //     return d.source.y;
    // })
    // .attr("x2", function(d){
    //     return d.target.x;
    // })
    // .attr("x1", function(d){
    //     return d.target.y;
    // });

    // console.log(simulation.alpha());
};

function dragStart(event, d) {
      {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        }
    };


function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
};

function dragEnded(event, d) {
    // if node has been dragged, activate pin response
    if (event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;

    // if d is selected, change color. 
    if (d.fixed == true) {
        d3.select(this)
        .select("circle")
        .style("fill", "#D72862")
    }
};

function clicked(event, d) {
        var circle = d3.select(this).select("circle");
        // Check if the node is already selected (red fill color)
        var isSelected = circle.attr("fill") === "#D72862";

        // Toggle node color
        if (isSelected) {
            // If already selected, turn it off
            circle.attr("fill", "steelblue");
        } else {
            // If not selected, turn it on
            circle.attr("fill", "E1E6EC");
        }
};

// define strength scale
// var strengthScale = d3.scaleLinear([d3.min(graphData.links, function(d) {return d.value;}),
//                                     d3.max(graphData.links, function(d) {return d.value;})],
//                                     [-100, 100]); // add strength scale


// work on node-specific forces
// l[0] is the source [IMPORTANT], not sure how to implement reference by string (l['source'])
// for (let i = 0; i < graphData.links.length - 1; i++){
//     console.log(i)
//     let l = graphData.links[i]
//     console.log("l:", l, l['source'], l['target'])
//     let sourceNode = graphData.nodes.find(function(node) {return node.name === l['source'];})
//     let targetNode = graphData.nodes.find(function(node) {return node.name === l['target'];})
//     let forceStrength = strengthScale(l['value'])

//     console.log("source:", sourceNode, "target:", targetNode, "forceStrength:", forceStrength)
//     // console.log(graphData.nodes.find(function(node) {return node.name === l[0];}));
//     // console.log("raw strength:", l['value'], "scaled strength:", strengthScale(l['value'])) 
//     //console.log("test access of nodes:", graphData.nodes.find(function(node) {return node.name === 'GBDC';}))
//     //console.log("node 0:", graphData.nodes[0], "node 1:", graphData.nodes[1])
//    // try to get sim force running with a single example, then advance to iterative process
//     simulation.force("charge", isolate(d3.forceManyBody()
//                                          .strength(forceStrength),
//                                                     sourceNode,
//                                                     targetNode)
//                                 );
                        //isolate(d3.forceManyBody().strength(100), graphData.nodes[0], graphData.nodes[1]))
                    
    // simulation.force(graphData.nodes[i].id.concat(graphData.nodes[j].id), 
    //                      isolate(d3.forceManyBodyReuse().strength(-30), graphData.nodes[i], graphData.nodes[j])
    
    //simulation.force(graphData.nodes[l.source])
//};

// ##### ORIGINAL EXAMPLE ######
// data.nodes contains all nodes
// for(let i = 0; i < graphData.nodes.length - 1; i++){
//     for(let j = i + 1; j < graphData.nodes.length; j++){
//         console.log("i", i, "j", j)
//         simulation.force(graphData.nodes[i].id.concat(graphData.nodes[j].id), 
//                          isolate(d3.forceManyBodyReuse().strength(-30), graphData.nodes[i], graphData.nodes[j]));
//     }
// }

// function isolate(force, nodeA, nodeB) {
//     let initialize = force.initialize;
//     force.initialize = function() { initialize.call(force, [nodeA, nodeB]); };
//     return force;
// }


    // Close data function and catch error if it exists
}).catch(function(error) {
        console.log(error);
});

</script>
</div>
