
<meta charset="utf-8">

<!-- Class style sheet in linked in .css -->
<link rel="stylesheet" href = "ticker_styles.css" type="text/css"/>

<script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
<script src="user_interactions.js"></script>
<!-- // Tutorial Link: https://www.youtube.com/watch?v=y2-sgZh49dQ -->

<!-- Set title (correct placement?)-->
<title>Corr Explore</title>

<!-- Create left hand column-->
<!-- Left Quarter Column -->
<div class="left-column">
    <div class="left-column-content">
        <!-- Content for the left column goes here -->
        <h2>Corr Explore</h2>
        <p><i>This is an exciting new way to visualize portfolio correlation.</i></p>
    
        <div class="slidecontainer">
            <input type="range" min="0" max="1" value="0.0" 
                step = "0.01" class="slider" id="corrRange">
                
        <!-- Display the selected value -->
        <p>Min. Correlation: <span id="corrMinValue">0.0</span></p>    
    </div>
<script>

    
//   // Add an event listener to the range slider
//   const rangeSlider = document.getElementById("corrRange");
//   const corrMinimumDisplay = document.getElementById("corrMinValue");

//     // Function to update node visibility based on the slider value
//     function updateNodeVisibility(corrMinvalue) {
//     graphData.nodes.attr("display", d => (d.Correlation >= corrMinvalue) ? "block" : "none");
//   }

//   rangeSlider.addEventListener("input", function() {
//     const corrMinValue = +this.value; // Convert the value to a number
//     corrMinimumDisplay.textContent = corrMinValue;
//     updateNodeVisibility(corrMinValue);
//   }
// );
</script>



<script>var slider = document.getElementById("corrRange");

</script>
      </div>
</div>

<!-- Create a div where the graph will take place -->
<div class="right-column">

<svg id = "graph-container" width="800" height = "800"></svg>

<script>
// select the svg container; add mouseover catching
var svg = d3.select("#graph-container");
var margin = {top: 20, right: 20, bottom: 30, left: 50}
var width = +svg.attr("width") - margin.left - margin.right;
var height = +svg.attr("height") - margin.top - margin.bottom;

console.log("slider:", slider.value)


// read in the ticker-level interaction data (pairwise correlation)
d3.dsv(',', 'data/ticker_corr3.csv', function(d) {
    //console.log(d.source, d.target, d.Correlation, d.norm_corr)
      return {
          source: d.source,
          target: d.target,
          correlation: +d.Correlation,
          value: isNaN(d.norm_corr) ? 0 : +d.norm_corr,
        }     
}).then(function(data) {

    var links = data;

    // read in the node data
    d3.dsv(',', 'data/ticker_nodes3.csv', function(d) {
    console.log(d.name, d.Correlation)
      return {
          name: d.name,
          Correlation: +d.Correlation,
        }
}).then(function(data2) {

var nodes = data2;

// filter nodes based on slider
// var nodes = nodes.filter(function(node) {
//     console.log("inside filter:", node.Correlation <= slider.value)
//     return node.Correlation <= slider.value;
// });

var graphData = {nodes:nodes, links:links};

// Notes
// fix drag functionality
// add/test charge strength where nodes are specifically attracted to one another... may have to be invisible links?
console.log("width:", width/2, "height:", height/2)

// function to scale the nodes
var nodeScale = d3.scaleLinear(d3.extent(graphData.nodes, d => d.Correlation), [10, 50])

// render issue was due to setting strength on forceCenter too high
var simulation = d3
        .forceSimulation(graphData.nodes)
        .force("charge", d3.forceManyBody().strength(4))//5
        .force("center", d3.forceCenter(width/2, height/2).strength(1))//1 
        .force("collide", 
            d3.forceCollide(function(d){
                return nodeScale(d.Correlation)
            })
            .strength(0.8))//0.7
        .on("tick", ticked);

var drag = d3
    .drag()
    .on("start", dragStart)
    .on("drag", dragged)
    .on("end", dragEnded);

  // Add an event listener to the range slider
  const rangeSlider = document.getElementById("corrRange");
  const corrMinimumDisplay = document.getElementById("corrMinValue");

//     // Function to update node visibility based on the slider value
//     function updateNodeVisibility(corrMinvalue) {
//     graphData.nodes.attr("display", d => (d.Correlation >= corrMinvalue) ? "block" : "none");
//   }

  rangeSlider.addEventListener("input", function() {
    const corrMinValue = +this.value; // Convert the value to a number
    corrMinimumDisplay.textContent = corrMinValue;
    //updateNodeVisibility(corrMinValue);
  }
);

// Create a tooltip
var Tooltip = d3.select("#graph-container")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("boarder", "solid")
                .style("boarder-width", "2px")
                .style("boarder-radius", "5px")
                .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    Tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }

//   var mousemove = function(d) {
//     Tooltip
//       .html("The exact value of<br>this cell is: " + d.Correlation)
//       .style("left", (d3.mouse(this)[0]+70) + "px")
//       .style("top", (d3.mouse(this)[1]) + "px")
//   }
  
var mousemove = function(event, d) {
    //console.log("event:", event)
    Tooltip
      .html("The exact value of<br>this cell is: " + d.Correlation)
      .style("left", (event.x +70) + "px")
      .style("top", (event.y) + "px")
  }

  var mouseleave = function(d) {
    Tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 1)
  }

var textsAndNodes = svg
    .selectAll("g")
    .data(graphData.nodes)
    .enter()
    .append("g")
    // .filter(function(d){ 
    //     console.log(d, d.Correlation, +corrMinimumDisplay.textContent)
    //     return d.Correlation >= +corrMinimumDisplay.textContent})
    .call(drag)
    .on("click", clicked)
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseout", mouseleave)

    // .on("mouseover", (event, d) => {
    //     // Create or select the tooltip div
    //     //let tooltip = d3.select("#graph-container").selectAll(".tooltip").data([d]);
    //     console.log("d:", d)
    //     let tooltip = d3.select("g").data([d]);//.attr("class", "tooltip");
    //     console.log("tooltip:", tooltip)
    //     tooltip = tooltip.enter()
    //                      .append("div")
    //                      .attr("class", "tooltip")
    //                      .merge(tooltip);

    //     console.log("tooltip2:", tooltip)

    //     // Update tooltip content and position
    //     tooltip
    //         .html(`Value: ${d.Correlation}`)
    //         .style("left", (event.pageX + 10) + "px")
    //         .style("top", (event.pageY - 20) + "px")
    //         .style("opacity", 1);
    //         })

    // .on("mouseout", () => {
    //     d3.select(".tooltip")
    //     //.attr("class", "node")
    //         .style("opacity", 0);
    // });
    
//textsAndNodes = textsAndNodes.filter(function(d){ return d.Correlation >= corrMinValue })

var circles = textsAndNodes
    .append("circle")
    .attr("class", "node")
    .attr("r", function(d){
        return nodeScale(d.Correlation);
    })
    .attr("fill", "steelblue")
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    ;

var texts = textsAndNodes.append("text")
                         .attr("class", "text")
                         .text(function(d){return d.name;})

function ticked() {
    //translate(x,y)
    textsAndNodes.attr("transform", function(d){
        return "translate(" + d.x + ", " + d.y + ")";
    });

};


// Define a function to update the visualization based on correlation threshold
function updateVisualization(correlationThreshold) {
    // Filter nodes based on the correlation threshold
    nodes = nodes.filter(function(node) {
        console.log('update vis fx:', node.Correlation, "corr threshold:", correlationThreshold, "logic:", node.Correlation < correlationThreshold)
        return node.Correlation < correlationThreshold;
    });

    // Update your visualization to display only the filtered nodes
    // Your visualization update code goes here
    // For example, you might update the node positions or remove nodes from the visualization
}


// Define slider
var slider = document.getElementById('corrRange');

// Function to update the slider position
function updateSliderPosition(value) {
    console.log("slider:", slider, "value:", slider.value)
    slider.value = value;
}

// Add event listener to the slider
slider.addEventListener('input', function() {
    var correlationThreshold = +this.value; // Convert slider value to a number
    updateVisualization(correlationThreshold);
    updateSliderPosition(+this.value);
});

// Add event listener to the slider
document.getElementById('corrRange').addEventListener('input', function() {
    var correlationThreshold = +this.value; // Convert slider value to a number
    updateVisualization(correlationThreshold);
});

function dragStart(event, d) {
      {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        }
    };

function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
};

function dragEnded(event, d) {
    // if node has been dragged, activate pin response
    if (event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;

    // if d is selected, change color. 
    if (d.fixed == true) {
        d3.select(this)
        .select("circle")
        .style("fill", "#D72862")
    }
};

function clicked(event, d) {
        var circle = d3.select(this).select("circle");
        // Check if the node is already selected (red fill color)
        var isSelected = circle.attr("fill") === "#D72862";

        // Toggle node color
        if (isSelected) {
            // If already selected, turn it off
            circle.attr("fill", "steelblue")
            circle.attr("stroke", "black");
        } else {
            // If not selected, turn it on
            circle.attr("fill", "#D72862")
            circle.attr("stroke", "white");
        }
};

// define strength scale
// var strengthScale = d3.scaleLinear([d3.min(graphData.links, function(d) {return d.value;}),
//                                     d3.max(graphData.links, function(d) {return d.value;})],
//                                     [-100, 100]); // add strength scale


// work on node-specific forces
// l[0] is the source [IMPORTANT], not sure how to implement reference by string (l['source'])
// for (let i = 0; i < graphData.links.length - 1; i++){
//     console.log(i)
//     let l = graphData.links[i]
//     console.log("l:", l, l['source'], l['target'])
//     let sourceNode = graphData.nodes.find(function(node) {return node.name === l['source'];})
//     let targetNode = graphData.nodes.find(function(node) {return node.name === l['target'];})
//     let forceStrength = strengthScale(l['value'])

//     console.log("source:", sourceNode, "target:", targetNode, "forceStrength:", forceStrength)
//     // console.log(graphData.nodes.find(function(node) {return node.name === l[0];}));
//     // console.log("raw strength:", l['value'], "scaled strength:", strengthScale(l['value'])) 
//     //console.log("test access of nodes:", graphData.nodes.find(function(node) {return node.name === 'GBDC';}))
//     //console.log("node 0:", graphData.nodes[0], "node 1:", graphData.nodes[1])
//    // try to get sim force running with a single example, then advance to iterative process
//     simulation.force("charge", isolate(d3.forceManyBody()
//                                          .strength(forceStrength),
//                                                     sourceNode,
//                                                     targetNode)
//                                 );
                        //isolate(d3.forceManyBody().strength(100), graphData.nodes[0], graphData.nodes[1]))
                    
    // simulation.force(graphData.nodes[i].id.concat(graphData.nodes[j].id), 
    //                      isolate(d3.forceManyBodyReuse().strength(-30), graphData.nodes[i], graphData.nodes[j])
    
    //simulation.force(graphData.nodes[l.source])
//};

// ##### ORIGINAL EXAMPLE ######
// data.nodes contains all nodes
// for(let i = 0; i < graphData.nodes.length - 1; i++){
//     for(let j = i + 1; j < graphData.nodes.length; j++){
//         console.log("i", i, "j", j)
//         simulation.force(graphData.nodes[i].id.concat(graphData.nodes[j].id), 
//                          isolate(d3.forceManyBodyReuse().strength(-30), graphData.nodes[i], graphData.nodes[j]));
//     }
// }

// function isolate(force, nodeA, nodeB) {
//     let initialize = force.initialize;
//     force.initialize = function() { initialize.call(force, [nodeA, nodeB]); };
//     return force;
// }


    // Close data function and catch error if it exists

}).catch(function(error) {
        console.log(error);
});

}).catch(function(error) {
            console.error("Error loading file 2:", error);
        });

</script>
</div>
